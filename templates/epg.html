{% extends "base.html" %}

{% block title %}EPG Viewer - MacReplay{% endblock %}

{% block head %}
<style>
    /* Toast notification styles */
    .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
    }
    .toast-notification {
        background-color: var(--bs-body-bg);
        border: 1px solid var(--bs-border-color);
        border-radius: 8px;
        padding: 15px 20px;
        margin-bottom: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        gap: 10px;
        animation: slideIn 0.3s ease;
        max-width: 350px;
    }
    .toast-notification.success {
        border-left: 4px solid var(--bs-success);
    }
    .toast-notification.info {
        border-left: 4px solid var(--bs-info);
    }
    .toast-notification.error {
        border-left: 4px solid var(--bs-danger);
    }
    .toast-notification .spinner-border {
        width: 1rem;
        height: 1rem;
    }
    @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    .epg-container {
        background-color: var(--bs-body-bg);
        border: 1px solid var(--bs-border-color);
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .epg-container.channels-box {
        background-color: rgba(13, 110, 253, 0.03);
        border-color: rgba(13, 110, 253, 0.2);
    }
    .epg-container.programmes-box {
        background-color: rgba(25, 135, 84, 0.03);
        border-color: rgba(25, 135, 84, 0.2);
    }
    .channel-list {
        max-height: 70vh;
        overflow-y: auto;
    }
    .channel-item {
        padding: 10px 15px;
        border-bottom: 1px solid var(--bs-border-color);
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .channel-item:nth-child(odd) {
        background-color: rgba(0, 0, 0, 0.02);
    }
    .channel-item:nth-child(even) {
        background-color: rgba(0, 0, 0, 0.05);
    }
    .channel-item:hover {
        background-color: rgba(13, 110, 253, 0.1);
    }
    .channel-item.active {
        background-color: #0d6efd;
        color: white;
    }
    .channel-logo {
        width: 40px;
        height: 40px;
        object-fit: contain;
        margin-right: 10px;
        background: var(--bs-tertiary-bg);
        border-radius: 4px;
    }
    .programme-list {
        max-height: 70vh;
        overflow-y: auto;
        padding: 15px;
    }
    .programme-item {
        padding: 12px 15px;
        margin-bottom: 8px;
        border-radius: 5px;
        background-color: rgba(0, 0, 0, 0.03);
        border-left: 4px solid var(--bs-secondary);
    }
    .programme-item.current {
        background-color: rgba(25, 135, 84, 0.15);
        border-left-color: #198754;
    }
    .programme-item.past {
        background-color: rgba(0, 0, 0, 0.06);
        opacity: 0.6;
    }
    .programme-item.future {
        background-color: rgba(13, 110, 253, 0.05);
        border-left-color: #6c757d;
    }
    .programme-time {
        font-size: 0.85rem;
        color: var(--bs-secondary-color);
    }
    .programme-item.current .programme-time {
        color: #198754;
        font-weight: 500;
    }
    .programme-title {
        font-weight: 500;
        margin: 5px 0;
    }
    .programme-desc {
        font-size: 0.85rem;
        color: var(--bs-secondary-color);
    }
    .now-indicator {
        display: inline-block;
        background-color: #198754;
        color: white;
        padding: 2px 8px;
        border-radius: 3px;
        font-size: 0.75rem;
        margin-left: 10px;
    }
    .no-programmes {
        text-align: center;
        padding: 40px;
        color: var(--bs-secondary-color);
    }
    .epg-header {
        background-color: var(--bs-tertiary-bg);
        padding: 15px;
        border-bottom: 1px solid var(--bs-border-color);
    }
    .progress-bar-wrapper {
        height: 3px;
        background-color: var(--bs-border-color);
        margin-top: 8px;
        border-radius: 2px;
        overflow: hidden;
    }
    .progress-bar-fill {
        height: 100%;
        background-color: #198754;
        transition: width 0.5s ease;
    }
    .btn-refresh {
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
    }
    .btn-refresh.refreshing {
        pointer-events: none;
    }
    .btn-refresh.refreshing i {
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    .programme-date-header {
        background-color: var(--bs-tertiary-bg);
        color: var(--bs-body-color);
        font-weight: 600;
        padding: 8px 15px;
        margin: 15px -15px 10px -15px;
        border-top: 1px solid var(--bs-border-color);
        border-bottom: 1px solid var(--bs-border-color);
        font-size: 0.9rem;
    }
    .programme-date-header:first-child {
        margin-top: 0;
        border-top: none;
    }
</style>
{% endblock %}

{% block content %}
<!-- Toast notifications container -->
<div class="toast-container" id="toastContainer"></div>

<div class="row">
    <div class="col-12">
        <h2><i class="fas fa-calendar-alt"></i> EPG Viewer</h2>
        <p class="text-muted">Electronic Program Guide - View current and upcoming programs</p>
    </div>
</div>

<div class="row mt-3">
    <div class="col-md-4">
        <div class="epg-container channels-box">
            <div class="epg-header d-flex justify-content-between align-items-center">
                <input type="text" class="form-control search-box me-2" id="channelSearch" placeholder="Search channels..." style="max-width: 200px;">
                <button class="btn btn-outline-primary btn-refresh" id="refreshEpgBtn" onclick="refreshEPG()" title="Refresh EPG data">
                    <i class="fas fa-sync-alt"></i>
                </button>
            </div>
            <div class="channel-list" id="channelList">
                <div class="text-center py-5 text-muted">
                    <i class="fas fa-spinner fa-spin fa-2x"></i>
                    <p class="mt-2">Loading channels...</p>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-8">
        <div class="epg-container programmes-box">
            <div class="epg-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0" id="selectedChannelName">Select a channel</h5>
                <small class="text-muted" id="lastUpdated"></small>
            </div>
            <div class="programme-list" id="programmeList">
                <div class="no-programmes">
                    <i class="fas fa-tv fa-3x mb-3"></i>
                    <p>Select a channel to view its program guide</p>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row mt-3">
    <div class="col-12">
        <small class="text-muted">
            <i class="fas fa-info-circle"></i>
            Channels: <span id="channelCount">0</span> |
            Programs: <span id="programmeCount">0</span> |
            Current: <span id="currentCount">0</span> |
            Last EPG update: <span id="epgLastUpdate">-</span> |
            Server TZ: <span id="serverTz">-</span> |
            EPG Range: <span id="epgRange">-</span>
        </small>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let epgData = { channels: [], programmes: [] };
let selectedChannel = null;

function loadEPG() {
    fetch('/api/epg')
        .then(response => response.json())
        .then(data => {
            epgData = data;
            renderChannelList();
            updateStats();

            // If a channel was selected, refresh its programmes
            if (selectedChannel) {
                showProgrammes(selectedChannel);
            }
        })
        .catch(error => {
            console.error('Error loading EPG:', error);
            document.getElementById('channelList').innerHTML =
                '<div class="text-center py-5 text-danger"><i class="fas fa-exclamation-triangle fa-2x"></i><p class="mt-2">Error loading EPG data</p></div>';
        });
}

function renderChannelList(filter = '') {
    const container = document.getElementById('channelList');
    const channels = epgData.channels || [];

    if (channels.length === 0) {
        container.innerHTML = '<div class="no-programmes"><i class="fas fa-tv fa-2x mb-2"></i><p>No channels available</p><p class="small">EPG data may still be loading</p></div>';
        return;
    }

    const filteredChannels = filter
        ? channels.filter(ch => ch.name.toLowerCase().includes(filter.toLowerCase()))
        : channels;

    let html = '';
    filteredChannels.forEach(channel => {
        const isActive = selectedChannel === channel.id ? 'active' : '';
        const currentProgramme = getCurrentProgramme(channel.id);
        const logo = channel.logo
            ? `<img src="${channel.logo}" class="channel-logo" onerror="this.style.display='none'">`
            : '<div class="channel-logo d-flex align-items-center justify-content-center"><i class="fas fa-tv"></i></div>';

        const portalInfo = channel.portal ? `<small class="text-muted d-block" style="font-size: 0.7em; opacity: 0.7;">${escapeHtml(channel.portal)}</small>` : '';

        html += `
            <div class="channel-item ${isActive}" onclick="selectChannel('${channel.id}', '${escapeHtml(channel.name)}')">
                <div class="d-flex align-items-center">
                    ${logo}
                    <div class="flex-grow-1">
                        <div class="fw-bold">${escapeHtml(channel.name)}</div>
                        ${portalInfo}
                        ${currentProgramme ? `<small class="text-muted">${escapeHtml(currentProgramme.title)}</small>` : ''}
                    </div>
                </div>
            </div>
        `;
    });

    container.innerHTML = html || '<div class="no-programmes">No channels match your search</div>';
}

function getCurrentProgramme(channelId) {
    const now = new Date();
    // Find all current programmes for this channel
    const currentProgs = epgData.programmes.filter(p => {
        const start = new Date(p.start);
        const stop = new Date(p.stop);
        const duration = stop - start;
        return p.channel === channelId &&
               start <= now &&
               stop > now &&
               duration > 0;
    });

    if (currentProgs.length === 0) return null;

    // Return the one with shortest duration (most specific)
    return currentProgs.reduce((best, prog) => {
        const bestDuration = new Date(best.stop) - new Date(best.start);
        const progDuration = new Date(prog.stop) - new Date(prog.start);
        return progDuration < bestDuration ? prog : best;
    });
}

function selectChannel(channelId, channelName) {
    selectedChannel = channelId;
    document.getElementById('selectedChannelName').textContent = channelName;

    // Update active state in channel list
    document.querySelectorAll('.channel-item').forEach(item => {
        item.classList.remove('active');
    });
    event.currentTarget.classList.add('active');

    showProgrammes(channelId);
}

function showProgrammes(channelId) {
    const container = document.getElementById('programmeList');
    const programmes = epgData.programmes.filter(p => p.channel === channelId);

    if (programmes.length === 0) {
        container.innerHTML = '<div class="no-programmes"><i class="fas fa-calendar-times fa-2x mb-2"></i><p>No program data available for this channel</p></div>';
        return;
    }

    const now = new Date();
    let html = '';
    let lastDateStr = '';

    // Find the BEST current programme (shortest duration that contains now)
    // This handles overlapping programmes from bad EPG data
    let bestCurrentProg = null;
    let bestCurrentDuration = Infinity;

    programmes.forEach(prog => {
        const start = new Date(prog.start);
        const stop = new Date(prog.stop);
        const duration = stop - start;

        if (start <= now && stop > now && duration > 0) {
            // This programme is currently running
            // Prefer the one with shortest duration (more specific)
            if (duration < bestCurrentDuration) {
                bestCurrentDuration = duration;
                bestCurrentProg = prog;
            }
        }
    });

    programmes.forEach(prog => {
        const start = new Date(prog.start);
        const stop = new Date(prog.stop);
        const duration = stop - start;
        const isPast = stop <= now;
        const isCurrent = start <= now && stop > now && duration > 0;
        const isFuture = start > now;

        // Only mark as "NOW" if this is the best current programme
        const isTheBestCurrent = bestCurrentProg && prog.start === bestCurrentProg.start && prog.stop === bestCurrentProg.stop;

        // Check if date changed - add date header
        const dateStr = formatDate(start);
        if (dateStr !== lastDateStr) {
            html += `<div class="programme-date-header">${dateStr}</div>`;
            lastDateStr = dateStr;
        }

        let statusClass = '';
        let nowBadge = '';
        let progressBar = '';

        if (isTheBestCurrent) {
            statusClass = 'current';
            nowBadge = '<span class="now-indicator">NOW</span>';

            // Calculate progress
            const total = stop - start;
            const elapsed = now - start;
            const progress = Math.min(100, Math.max(0, (elapsed / total) * 100));
            progressBar = `<div class="progress-bar-wrapper"><div class="progress-bar-fill" style="width: ${progress}%"></div></div>`;
        } else if (isPast) {
            statusClass = 'past';
        } else if (isFuture) {
            statusClass = 'future';
        } else if (isCurrent && !isTheBestCurrent) {
            // Overlapping current programme but not the best one
            statusClass = 'past';
        }

        const timeStr = `${formatTime(start)} - ${formatTime(stop)}`;
        const description = prog.description && prog.description !== prog.title
            ? `<div class="programme-desc">${escapeHtml(prog.description)}</div>`
            : '';

        html += `
            <div class="programme-item ${statusClass}">
                <div class="programme-time">${timeStr}${nowBadge}</div>
                <div class="programme-title">${escapeHtml(prog.title)}</div>
                ${description}
                ${progressBar}
            </div>
        `;
    });

    container.innerHTML = html;

    // Scroll to current programme
    const currentProg = container.querySelector('.programme-item.current');
    if (currentProg) {
        currentProg.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

function formatDate(date) {
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    if (date.toDateString() === today.toDateString()) {
        return 'Heute';
    } else if (date.toDateString() === tomorrow.toDateString()) {
        return 'Morgen';
    } else if (date.toDateString() === yesterday.toDateString()) {
        return 'Gestern';
    } else {
        return date.toLocaleDateString('de-DE', { weekday: 'long', day: '2-digit', month: '2-digit' });
    }
}

function formatTime(date) {
    return date.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function updateStats() {
    document.getElementById('channelCount').textContent = epgData.channels?.length || 0;
    document.getElementById('programmeCount').textContent = epgData.programmes?.length || 0;

    if (epgData.last_updated) {
        const lastUpdate = new Date(epgData.last_updated * 1000);
        document.getElementById('epgLastUpdate').textContent = lastUpdate.toLocaleString('de-DE');
    }

    // Debug info from API
    if (epgData.debug) {
        document.getElementById('currentCount').textContent = epgData.debug.current_programme_count || 0;
        document.getElementById('serverTz').textContent = epgData.debug.container_tz || '-';

        // Show EPG time range
        if (epgData.debug.earliest_programme && epgData.debug.latest_programme) {
            const earliest = new Date(epgData.debug.earliest_programme);
            const latest = new Date(epgData.debug.latest_programme);
            document.getElementById('epgRange').textContent =
                earliest.toLocaleString('de-DE', {day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'}) +
                ' - ' +
                latest.toLocaleString('de-DE', {day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'});
        }
    }

    document.getElementById('lastUpdated').textContent = 'Updated: ' + new Date().toLocaleTimeString('de-DE');
}

// Search functionality
document.getElementById('channelSearch').addEventListener('input', function(e) {
    renderChannelList(e.target.value);
});

// Toast notification system
function showToast(message, type = 'info', duration = 0) {
    const container = document.getElementById('toastContainer');
    const toast = document.createElement('div');
    toast.className = `toast-notification ${type}`;

    let icon = '';
    if (type === 'success') {
        icon = '<i class="fas fa-check-circle text-success"></i>';
    } else if (type === 'error') {
        icon = '<i class="fas fa-exclamation-circle text-danger"></i>';
    } else if (type === 'info') {
        icon = '<div class="spinner-border text-info" role="status"></div>';
    }

    toast.innerHTML = `${icon}<span>${message}</span>`;
    container.appendChild(toast);

    if (duration > 0) {
        setTimeout(() => {
            toast.style.animation = 'slideIn 0.3s ease reverse';
            setTimeout(() => toast.remove(), 300);
        }, duration);
    }

    return toast;
}

function removeToast(toast) {
    if (toast && toast.parentNode) {
        toast.style.animation = 'slideIn 0.3s ease reverse';
        setTimeout(() => toast.remove(), 300);
    }
}

// Poll EPG refresh status
async function pollEpgStatus(toast) {
    const maxAttempts = 120; // Max 2 minutes (120 * 1 second)
    let attempts = 0;

    while (attempts < maxAttempts) {
        try {
            const response = await fetch('/api/epg/status');
            const data = await response.json();

            if (!data.is_refreshing) {
                // Refresh complete
                removeToast(toast);
                showToast('EPG refresh complete!', 'success', 3000);

                // Reload EPG data
                loadEPG();

                const btn = document.getElementById('refreshEpgBtn');
                btn.classList.remove('refreshing');
                btn.disabled = false;
                return true;
            }
        } catch (e) {
            console.error('Error polling EPG status:', e);
        }

        await new Promise(resolve => setTimeout(resolve, 1000));
        attempts++;
    }

    // Timeout
    removeToast(toast);
    showToast('EPG refresh timed out', 'error', 5000);
    const btn = document.getElementById('refreshEpgBtn');
    btn.classList.remove('refreshing');
    btn.disabled = false;
    return false;
}

// Refresh EPG data
function refreshEPG() {
    const btn = document.getElementById('refreshEpgBtn');
    btn.classList.add('refreshing');
    btn.disabled = true;

    fetch('/api/epg/refresh', { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'started' || data.status === 'success' || data.status === 'already_running') {
                // Show loading toast and start polling
                const toast = showToast('EPG wird aktualisiert...', 'info');
                pollEpgStatus(toast);
            } else {
                showToast('Error: ' + (data.message || 'Unknown error'), 'error', 5000);
                btn.classList.remove('refreshing');
                btn.disabled = false;
            }
        })
        .catch(error => {
            console.error('Error refreshing EPG:', error);
            showToast('Error refreshing EPG', 'error', 5000);
            btn.classList.remove('refreshing');
            btn.disabled = false;
        });
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    loadEPG();

    // Refresh EPG data every 5 minutes
    setInterval(loadEPG, 5 * 60 * 1000);

    // Update current programme progress every 30 seconds
    setInterval(() => {
        if (selectedChannel) {
            showProgrammes(selectedChannel);
        }
    }, 30000);
});
</script>
{% endblock %}
